[
["index.html", "KUT 計量経済学応用 統計的因果推論入門 はじめに 0.1 この資料について 0.2 履修条件 0.3 R とRStudio のインストール 0.4 授業計画", " KUT 計量経済学応用 統計的因果推論入門 矢内 勇生 2020-06-11 はじめに 0.1 この資料について この資料は、高知工科大学経済・マネジメント学群で2020年度に開講する「計量経済学応用」の補助教材である。 受講生は、以下の点に注意されたい。 この資料は、授業の進捗にあわせてアップデートされる。 公開時点（2Q開始時点）では、すべてのトピックの説明が完成していない。 各トピックの説明は順次追加する。 一度アップロードしたトピックの内容を修正するときは、Slack でアナウンスする。 ただし、誤字・脱字等については気付いたらアナウンスせずに修正する。 この資料以外の授業資料（解説音声付きスライドや配布資料など）は、KUTLMS (Moodle) にアップロードする。 この資料以外に教科書が必要である。 教科書：安井翔太. 2020.『効果検証入門：正しい比較のための因果推論/計量経済学の基礎』（技術評論社） 購入するのは電子版（例えば、Kindle版）でも良い。 0.2 履修条件 この授業は、「計量経済学」（とその前提となる「統計学2」）を履修済みであることを前提に進める。そのため、この授業（この資料）では： 基本的な統計用語・統計量（例：分散、共分散、最小二乗推定量、有意水準）や基本的な手続き（例：仮説検定）は説明しない。 R とRStudio の基本的な使い方は説明しない。以下を思い出しておくこと。 RStudio のプロジェクト機能の使い方。 ggplot2 による作図の方法。 RMarkdownの書き方。特に、文章とコードチャンクの使い分け。 これらの点に不安がある場合は、2Qの早い時期（6月の第3週頃まで）に自分で計量経済学の内容を学習（復習）するか、今年度の3Qに「計量経済学」を受講してから、来年度の「計量経済学応用」を受講すること。自分で学習する場合は、最低でも浅野正彦・矢内勇生『Rによる計量政治学』（2018年、オーム社）の第4章から第14章までの内容を学習すること。 0.3 R とRStudio のインストール RとRStudio を自分のパソコンにインストールして使いたい場合は、私が作った以下の資料を参照されたい。 Linux (Ubuntu) 編 (PDF, 4.6MB) macOS 編 (PDF, 4.9MB) Windows 編 （PDF, 5.8MB) 0.4 授業計画 以下の内容を扱う予定である（カッコ内は何回目の授業で扱うかの目安）。 イントロダクション（第1回） セレクションバイアス（第2回） RCT（第3回） 回帰分析（第4回、第5回） 傾向スコア（第6回、第7回） パネルデータ分析（第8回、第9回） 分析計画のプレゼンテーション（第10回） 回帰不連続デザイン（第11回、第12回） 操作変数法（第13回、第14回） 分析結果のプレゼンテーション（第15回） 各トピックの参考文献や予習課題については、シラバス（PDFファイル） を参照されたい。 この資料は上に挙げたトピック単位で作成している。各トピックに例として書かれたRコードは、トピックを途中から実行することを想定していない。たとえば、1.3.6節に書いてあるコードを実行するためには、トピック1の冒頭から 順番にRコードを実行する必要がある。途中のコードだけ実行しても動かない可能性が高い。 他方、各トピックは独立に実行できる。例えば、トピック3に書かれているコードを実行するために、トピック1や2に書かれたRコードを実行する必要はない。トピック3の冒頭から実行すれば十分である。 ただし、トピック1の内容は全員1度は実行済みであると仮定する。1度実行すれば、Rをインストールし直すか、バージョンアップするまでは再度実行する必要はない。 "],
["introduction.html", "Topic 1 イントロダクション 1.1 予習と講義動画の視聴 1.2 Slack 1.3 RStudio Cloud の初期設定 1.4 トピック1の課題", " Topic 1 イントロダクション 1.1 予習と講義動画の視聴 トピック1でやるべきことは、以下のとおりである。 シラバス(PDFファイル) をよく読む。遠隔授業に変更になったことにより、大学の公式サイトに載っているものとは内容が異なるので、このリンクにある最新のPDF版を読むこと。 KUTLMS (Moodle) にあるトピック1の講義動画を視聴する。 この資料の続きを読み、トピック2以降の授業に備える。 特に、最後の課題を忘れずに。 1.2 Slack 1.2.1 Slack とは？ この授業では、担当教員と受講生の間、あるいは受講生同士の間の連絡手段として、Slack を使う。この授業には無料版で十分なので、間違って支払いをしないように注意。 授業に関連する連絡や、オフィスアワー以外の質問の受付はすべてSlack で行うので、必ずSlackが使えるようにしておくこと。準備期間として6月18日まではメールでの質問も受け付けるが、その後は基本的にメールでの質問は受け付けない（とは言っても、実際にはメールに気付けば回答する。メールはたまにしかチェックしない上に、知らない人からのメール（送信者名が設定されていないメール）や添付ファイルがあるメールは読まないので、メールで質問しても読まれていないと思ったほうがいいというだけのことである。また、Slackのほうが回答が早い）。 スマホ用のアプリもあるが、課題の提出とフィードバック（つまり、ファイルの送受信）に利用するので、パソコンで使えるようにしておくこと。パソコンでは、パソコン用のアプリを使うか、アプリをインストールせずにウェブブラウザ上で使うことができる。 Slack を使ったことがないなら、以下の資料が参考になる。 Slack 初心者のためのクイックスタートガイド 【完全初心者向け！】コミュニケーションツールSlack（スラック）の使い方 初心者がSlackを使いこなすために知っておきたい6つのポイント 1.2.2 授業用ワークスペースへの登録 この授業専用のSlack ワークスペース「計量経済学応用」に登録するためのURLは、ポータルから送信済みである（2020年6月8日午前8時に送信）。登録済みでない者は、ポータルのメッセージを確認すること。登録には、KUTのメールアドレス ((???)) が必要である。 メンバー登録するときに決める表示名は、匿名でもかまわない（ただし、担当教員はメールアドレスから個人を特定できるので注意）。 KUTのメールアドレスがどうしても使えないという場合は、以下の内容のメールを担当教員宛に送ること（メールアドレスはシラバス・講義スライドに記載されている）。 件名（メールのタイトル）：計量経済学応用 Slack用メールアドレス 本文に以下の内容を記載 氏名 学籍番号 Slackへの登録で使いたいメールアドレス 匿名での登録を希望する場合、希望の「表示名」（後で変更可能; 指定がない場合は本名で登録する） 必要事項が記載されたメールが届いたら登録する。登録確認のメールが届くはずなので、確認すること。 1.2.3 利用上の注意 Slack での発言は授業への参加点に加算するので、積極的に質問してほしい。また、質問だけでなく、他の受講生からの質問に回答したり、Slack 上で議論することも歓迎する（加点する）。対面授業であれば授業中に議論できるが、2020年度の授業は遠隔で実施することになり、毎回 Zoom 等で議論する時間的余裕もない。そこで、Slack で議論の場を設けることとしたい。 また、初めての遠隔授業で担当教員も暗中模索の状態なので、授業の進め方に関する意見も歓迎する。 Slack に投稿する際には以下の点に気をつけてくれると嬉しい（守らなくても減点するわけではない）。 余計な挨拶を毎回書かないこと（メールではないので） 「余計」なものの例： 「お世話になっております」（私の心の声：「早く本題に入って」） 「計量経済学を受講している〇〇です」（「そうでしょうね。名前は表示されてますよ。」） 「経済・マネジメント学群3年の〇〇です」（「経・マネの学生なんて珍しいですね（棒読み）。名前は…(略）」） 「質問してもいいですか？」（「早く質問して」） どの内容についての質問か明確にすること 授業を決められた時間に受ける必要はないので、人によって受講するペースが違うことが想定される：「今日の授業」と言われてもどの授業かわからない 例えば、以下のように質問してくれるとわかりやすい 操作変数法のスライドの、p.15 について質問：（以下、質問の内容） 補助教材の 1.3.3 のカスタマイズについて質問：（以下、質問の内容） 課題4の問3について：（以下、質問の内容） 投稿の際は、適切なチャンネルを選ぶこと 特に、ダイレクトメッセージの場合には、誤った相手に送信しないように注意 提出したファイルが届いたかどうか質問しないで！ Slack上にファイルがアップロードされていることをあなたが確認できれば、私からも見えるのでご心配なく。 この質問の優先順位は最下位に設定する 禁止事項：以下の行為は禁止する 他人を誹謗・中傷するような書き込み 他人の著作物のアップロード これらの行為は学業上の不正行為である。見つけた場合には教務部に報告する。万が一、他の受講生からハラスメント行為を受けた場合は、証拠を保全（スクリーンショットを撮るなど）して担当教員に連絡してほしい。皆さんはもう大学3年生なので、誹謗・中傷（相手を貶める行為）と批判（相手を高めるために、相手の「議論」の弱点を指摘して、改善策を一緒に見つけること）の違いをわきまえましょう。 1.3 RStudio Cloud の初期設定 まず、RStduio Cloud を使うための初期設定をしよう。RStudio Cloud ではなく、自分のパソコンにインストールした（あるいは情報演習室のパソコンにインストールされている）RStudio を使う場合は、自分の環境に合わせて適宜読み替えること。 念のためにもう1度注意しておくが、この授業は「統計学2」と「計量経済学」を受講済みであることを前提にしている。よって、受講生は全員RStudio（デスクトップ版）の基本的な使い方を理解していると仮定して、RStudio Cloud の使い方を説明する。 たとえば、「プロジェクトとは何？」、「パッケージとは何？」という疑問がある人は、この資料を読んでも内容が理解できないかもしれない。そういう人は、「統計学2」や「計量経済学」を先に受講（あるいは復習）してからもう一度挑戦してほしい。 1.3.1 ユーザ登録 RStudio Cloud にアクセスしてログイン (Log In) する。初めて使う場合は、登録（サインアップ [Sign Up]）が必要である。自分で決めたパスワードを忘れないように注意。 1.3.2 授業用のプロジェクトを作る RStudio Cloud のアカウントを作り、無事にログインできたら、この授業で使うプロジェクトを作ろう。 Projects タブを開いて [New Project] ボタンを押せば、新しいプロジェクトを作成することができる。 新規プロジェクトが立ち上がると、画面上部に [Your Workspace / Untitled Project] と表示されるので、“Untitled Project” の部分をクリックしてプロジェクトに名前を（アルファベットと数字で）つけよう。好きな名前をつけて良い。2つ目の計量経済学 (Econometics) の授業なので、“metrics2” などとしておけばいいだろう。 デスクトップ版のRStudio を使う場合は、いつも通りの方法で授業用のプロジェクトを作ろう。 1.3.3 RStudio のカスタマイズ まず、RStudio Cloud を自分が使いやすいようにカスタマイズしよう。[Tools] -&gt; [Global Options] を開いてカスタマイズする。どのようにカスタマイズすべきかについては、RとRStudio のインストール方法を解説した資料 の後半に書いてある。 デスクトップ版とは異なり（実際には、デスクトップ版でも複数のバージョンをインストールしていれば選べるが）、RStudio Cloud ではRのバージョンが選べるので、Global Options の [General] -&gt; [Basic] で、[Default versions of R:] を **R version 3.6.3\" に設定しよう。 （この資料を作成した時点での最新版は R 4.0.0 である。大学の情報演習室にインストールされているのが R 3.6.3 であり、今年度中は更新されないので、そちらに合わせる。2020年6月9日現在、自分のパソコンに新たにR をインストールするとバージョンが4.0.1になるはずだが、その場合はその 4.0.1 で問題ない。） 1.3.4 パッケージのインストール 次に、授業で使うことが予想されるパッケージをインストールしてしまおう。 まず、RStuido Cloud で新たにR Markdown ファイルを作成してみよう（File -&gt; New File -&gt; R Markdown）。初めてこれをやると、次のような表示が出るはずだ。 これが表示されたら、[Yes] をクリックしよう。すると、RMarkdown を使うために必要なパッケージがインストールされる。あとはデスクトップ版と同じようにR Markdown ファイルが使える。 続いて、「計量経済学」の授業でも毎回お世話になった tidyverse パッケージをインストールしよう。RStudio Cloud の Console で次のコードを実行する。 install.packages(&quot;tidyverse&quot;) このインストールには少し時間がかかる。待っている間に、tidyverseがggplot2, dplyr, readr などの便利なパッケージをまとめたパッケージ群であることを思い出そう。最近、dplyr のバージョンが上がり、「計量経済学」で勉強したときとは使い方が少し変わっているので注意しよう（授業で説明するので心配無用）。 次に、pacman パッケージをインストールする。 install.packages(&quot;pacman&quot;) pacman パッケージは、パッケージの読み込みとインストールに利用する。 これまでは、install.packages() でパッケージをインストールし、インストール済みのパッケージをlibrary() で読み込んで使っていた。この方法は、今後も引き続き使える。しかし、この方法だと、library() を使うためにはパッケージがインストール済みでなければいけないという問題がある（実際には全然「問題」ではなく、単に面倒だというだけ）。 この問題は。pacman::p_load() を使うことで（ほとんどの場合）解決する。この方法の利点は2つある。 インストール済みでないパッケージを指定すると、（そのパッケージがCRANに登録されていれば）読み込む前にインスト－ルしてくれる。 複数パッケージの読み込みが一度にできる。 試しに、既にインストール済みの tidyverse と、まだインストールしていない（はずの）patchwork、estimatr, devtools, showtextの計5 つのパッケージを同時に読み込んでみよう。 pacman::p_load(tidyverse, patchwork, estimatr, devtools, showtext) patchwork 、estimatr、devtools、showtext の4つのパッケージのインストールと、既にインストール済みのtidyverseを合わせた5つのパッケージの読み込みが完了した。 試しに使ってみよう。 set.seed(321) myd &lt;- tibble(x = rnorm(100), y = rnorm(100)) p1 &lt;- ggplot(myd, aes(x = x, y = after_stat(density))) + geom_histogram(binwidth = 0.25, color = &quot;black&quot;) + ylim(0, 0.6) p2 &lt;- ggplot(myd, aes(x = y, y = after_stat(density))) + geom_histogram(binwidth = 0.25, color = &quot;black&quot;, fill = &quot;dodgerblue&quot;) + ylim(0, 0.6) plot(p1 + p2) tibble とggplot2 (どちらもtidyverseに含まれる) と patchwork が使えることがわかる。 pacman::p_load() で書いたコマンドは、pacman なしだと次のように書かなければならない。 install.pakcages(c(&quot;patchwork&quot;, &quot;estimatr&quot;, &quot;devtools&quot;, &quot;showtext&quot;)) library(tidyverse) library(patchwork) library(esimatr) library(devtools) library(showtext) 複数のパッケージを読み込むだけ（すべてのパッケージがインストール済み）なら次のようにも書けるが、やや面倒だ。 sapply(c(&quot;tidyverse&quot;, &quot;patchwork&quot;, &quot;estimatr&quot;, &quot;devtools&quot;, &quot;showtext&quot;), require, character.only = TRUE) 今後、この授業では pacman::p_laod() でパッケージの読み込みを行う。 ただし、CRANに登録されていないパッケージは手動でインストールする必要がある。GitHub にアップロードされているパッケージは、devtools::install_github() または remotes::install_github() でインストールする。 試しに、宋財泫 (SONG Jaehyun) さんが作って GitHub で公開している BalanceR パッケージをインストールしてみよう。 devtools::install_github(&quot;JaehyunSong/BalanceR&quot;) インストールさえ済めば、pacman::p_load() が使える。 pacman::p_load(BalanceR) CRANに登録されていないパッケージを授業で使う場合は、その都度インストールを指示する。 1.3.5 ディレクトリの作成 授業でよく使うディレクトリ（フォルダ）を作っておこう。（ファイルパスに自分で対応できるなら、ここは自分の好みで変えて良い。） dir.create() で2つのディレクトリを作る。 dir.create(&quot;data&quot;) dir.create(&quot;figs&quot;) 今後、授業で使うデータセットは data ディレクトリに、作成した図は figs ディレクトリに保存する。 1.3.6 図で日本語が使えるようにする 日本語の論文・レポート用に図を作るとき、軸ラベルやタイトルには日本語を使う。RStudio Cloud ではなくデスクトップ版のRStudio を使うとき、Windowsなら特に何もしなくてもggplot2 で日本語が使える（この資料はmacOS で作っているので、図は省略）。 p1_jp &lt;- p1 + labs(y = &quot;確率密度&quot;, title = &quot;ヒストグラム（日本語のテスト）&quot;) plot(p1_jp) Mac でも、次のようにthem_set() で base_family を指定すれば日本語が使える。 theme_set(theme_gray(base_size = 10, base_family = &quot;HiraginoSans-W3&quot;)) p1_jp &lt;- p1 + labs(y = &quot;確率密度&quot;, title = &quot;ヒストグラム（日本語のテスト）&quot;) plot(p1_jp) しかし、RStudio Cloud だと次のような図になってしまう。 この問題に対処するために、日本語が表示できるフォントを使う。次のように指定する。 sysfonts::font_add_google(name = &quot;Noto Sans JP&quot;, family = &quot;noto&quot;) showtext::showtext_auto() theme_set(theme_gray(base_size = 10, base_family = &quot;noto&quot;)) 上のコマンドを実行したら、もう1度図を表示してみる plot(p1_jpn) 図は省略するが、RStudio Cloud に表示されている図では、先ほどと同じように日本語が文字化けしているだろう。 しかし、これをファイルに保存すれば、日本語が正しく表示される。 次のコマンドで図をPDFファイルに保存する。（PNGファイルにするには、.pdfを.png に変えれば良い。ただし、上の base_size のところで文字サイズを調整する必要がある。） ggsave(filename = &quot;figs/japanese-test.pdf&quot;, plot = p1_jpn, width = 4, height = 3) figs ディレクトリに japanese-test.pdf というファイルができているので、クリックして開いてみよう。日本語が正しく表示されているはずだ。 1.3.7 R Markdown からPDFファイルを作る 統計学2と計量経済学では、R Markdown からHTML ファイルを作る（“knit” する）方法を学んだ。 そのときに少し説明したが、R Markdown からPDF ファイルを作ることもできる。今年度は遠隔授業でファイルによる課題提出が必要になるので、HTMLをブラウザに表示したものを印刷して提出する代わりに、PDFファイルで提出してもらう。（どうしても HTMLしかできなれけば、HTMLブラウザで表示して、表示された内容 を「ファイルに印刷」してPDFファイルを作ってもかまわない。） そこで、R Markdown ファイルからPDFファイルを作る方法を説明する。この方法を身につければ、卒業論文も R Markdown で書ける（草川先生が作ってくれた卒論用テンプレートがある。草川先生に感謝しましょう）。 必要なパッケージをインストールするが、デスクトップ版のRStudio を使っていて、既にLaTeX （TeX Live やMacTeX など）がインストールされているなら、これはインストールしなくて良い（しないほうが良いかも）。 まず、次のコマンドを実行して tinytex をインストールする。 pacman::p_load(tinytex) install_tinytex() デスクトップ版のRStudio を使っている場合は、インストールが完了したら一旦RStudio を終了し、再起動する。 これができたら、.Rmd ファイルのYAMLヘッダを以下のように書けば、本文に日本語を含む PDF ファイルが knit できる（初めてPDFをknitするときは、追加で必要なものがインストールされる [よって、ネット接続が必須] ので時間がかかる。）。date 以下はコピペで良い。 --- title: &quot;計量経済学応用&quot; subtitle: &quot;日本語PDFできるかな&quot; author: &quot;猫好きのRユーザ&quot; date: &quot;`r Sys.Date()`&quot; output: pdf_document: highlight: tango latex_engine: xelatex toc: false header-includes: - \\usepackage{zxjatype} - \\usepackage[haranoaji]{zxjafont} documentclass: bxjsarticle --- ただし、この時点では図の中に日本語があるとエラーが出るので、日本語入りの図がない状態で一度 knit してみよう。（ここでは、haranoaji で原ノ味フォントを指定している。自分で他のフォントが使える状態にできるなら、他のフォントでも良い。例えば、ヒラギノフォント [hiragino-pron] やIPAex フォント [ipaex] などにしても良いだろう。） しかし、RStduio Cloud では、平仮名の「う」がなぜが表示されない（誰か助けて…）。他にも表示されない文字があるかもしない（気付いたら教えてほしい）。この授業では、「う」が表示されていなくても大目に見る（皆さんのせいではないので）。 また、出来上がったPDFファイルをクリックしてダウンロードすると、ファイル名が file_show に代わり、ファイル名拡張子もなくなっている。これはファイルをダウンロードした後に自分でファイル名を付け直す（.pdf も忘れずに）か、次の手順でファイルをダウンロードすれば良い（ggplotで作った図をPDFにした場合にも、この方法を使う）。 RStudio Cloud の[Files] タブで、ファイル名の左にあるチェックボックスにチェックをつける。 [More] -&gt; [Export] を選択する。 正しいファイル名が表示されていることを確認して [Download] をクリックする。 日本語を使った図が含まれるR Markdown ファイルをPDF にknit するためには、次のようなRチャンクをR Markdown ファイルの最初のほう（YAML ヘッダのすぐ後）に書いておく。 ```{r global_option, include = FALSE} knitr::opts_chunk$set(warning = FALSE, echo = TRUE, message = FALSE, fig.height = 3, fig.width = 4, dev = &quot;cairo_pdf&quot;) ``` ここで重要なのは、 dev = \"cairo_pdf\" を指定することである。 また、デスクトップ版のRStudioでは、PDFに日本語の図を入れる際に日本語フォントの指定が必要である。 （Macを使っていてXQuartz もインストールされているなら、cairo_pdf の代わりに quartz_pdf も使える。） Macならいつも通りに、 theme_set(theme_gray(base_size = 10, base_family = &quot;HiraginoSans-W3&quot;)) と、書く。 Windows でも、PDF をknit する場合には同様の作業が必要である。ヒラギノフォントが使えないので、次のようにする。 theme_set(theme_gray(base_size = 10, base_family = &quot;Meiryo&quot;)) Ubuntuの場合は、（IPAex フォントがあるという前提で）次のようにする。 theme_set(theme_gray(base_size = 10, base_family = &quot;ipaex&quot;)) これらのうち、自分のOSに合ったもの1つを、tidyverse（または ggplot2） パッケージを読み込んだ直後に一度書いておけばよい。これで、図に日本語が含まれていても PDFがknit される。 ただし、RStudio Cloud を使っている場合は、これでも文字化けが直らない。文字化けした図が表示されるようになるだけである。このように、RStudio Cloud は日本語の処理に難がある。 この授業では、図のラベルや凡例などはすべて英語でも減点しない。意味がわかればローマ字 でも良い （例：Mitsudo）。しかし、これは不便なので、やはり自分のパソコンにRとRStudio をインストールして使ったほうが良いだろう。インストール手順については、ココ にある資料を参照。 .Rmd ファイルのサンプルをRStudio Cloud 上の KUT_R プロジェクト に 置いておくので、必要なら自分のOS用のファイルをダウンロードして中身を確認されたい。 macOS用：jpntest_mac.Rmd Ubuntu用：jpntest_ubuntu.Rmd Windows用：jpntest_win.Rmd RStudio Cloud用：jpntest_cloud.Rmd （図の日本語は文字化けする） RStudio Cloud を閉じるとき、ブラウザ（あるいはタブ）を閉じてもRセッションが終了しないので、コンソールにq(\"no\")と入力してRを終了しよう。 1.4 トピック1の課題 上のサンプル（.Rmd ファイル）を参考にして、R Markdown ファイルから PDFファイルを作りなさい。その際、以下の指示を守ること。 図をヒストグラム以外（例えば、バイオリン図や散布図など）に変えなさい。 図の説明を日本語で加えなさい（1文で十分）。 ヘッダ部分に、自分の氏名を書きなさい。 サブタイトルは、「課題1」に変えなさい。 提出するファイル名：metrics2_hw01_LastFirst.pdf LastFirstの部分を自分の名前に変えること。 例：metrics2_hw01_YanaiYuki.pdf 提出期限：2020年6月19日午後5時（日本時間） 提出方法：Slack のダイレクトメッセージで矢内に送る。 "],
["selection-bias.html", "Topic 2 セレクションバイアス 2.1 予習、講義動画、実習課題 2.2 セレクションバイアスのシミュレーション 2.3 トピック2の課題", " Topic 2 セレクションバイアス トピック2の講義スライド (PDF, 2.6MB) 2.1 予習、講義動画、実習課題 このトピックでやるべきことは、以下のとおりである。 シラバス(PDFファイル) に記載されているトピック2の予習課題を読む。 KUTLMS (Moodle) にあるトピック2の講義動画を視聴する。 この資料の続きを読み、Rを使った実習を行うことでセレクションバイアスの理解を深める。 まず、書いてあるコードをそのまま実行する。 自分で数字（シミュレーションの条件）を変えて、結果がどう変わるか研究する（これが課題）。 （おまけ：希望者のみ）Josh Angrist による以下の解説動画（英語）を視聴する。 Ceteris Paribus （他の条件が等しければ） Selection Bias（セレクションバイアス） 2.2 セレクションバイアスのシミュレーション 2.2.1 準備 必要なパッケージを読み込み、作図用の日本語フォントを設定する。 pacman::p_load(tidyverse) theme_set(theme_gray(base_size = 10, base_family = &quot;HiraginoSans-W3&quot;)) # macOS用 #theme_set(theme_gray(base_size = 10, base_family = &quot;Meiryo&quot;)) # Windows用 #theme_set(theme_gray(base_size = 10, base_family = &quot;ipaex&quot;)) # Ubuntu用 #showtext::showtext_auto() # Cloud用 #theme_set(theme_gray(base_size = 10, base_family = &quot;noto&quot;)) # Cloud用 2.2.2 メールによる販促の効果 教科書 (安井 2020) の第1章（pp.4-6）にある、メールによる販売促進施策のセレクションバイアスを、シミュレーションによって確かめてみよう。 まず、対象全体の人数を決める。 N &lt;- 1000 次に、N人をメールがないときに商品を買いやすいグループAと、商品をあまり買わないグループBに分けよう。ここでは、同じ人数に分けることにする。 d1 &lt;- tibble(group = rep(c(&quot;A&quot;, &quot;B&quot;), each = N /2)) グループAとBが、メールを受け取らなかったときに商品を買う確率 pA と pB を決める。ただし、pA \\(&gt;\\) pB である。 pA &lt;- 0.6 pB &lt;- 0.3 次に、誰にメールを送るかを決めよう。教科書 (安井 2020) に書かれているとおり、元々商品を買いそうな人にメールを送りやすいと考えて、各グループのメンバがメールを受け取る確率をそれぞれ pA / (pA + pB)、pB / (pA + pB ) としよう。また、メールは全部で N/2 人に送ることにする。メールを受け取れば1、受けとらなければ0をとる mail という変数を作る。 n_mail &lt;- N / 2 n_receive &lt;- round(n_mail * c(pA, pB) / sum(pA, pB)) d1$mail &lt;- rep(c(1, 0, 1, 0), times = c(n_receive[1], N / 2 - n_receive[1], n_receive[2], N / 2 - n_receive[2])) メールを送ることによって商品を購入する確率がどれくらい上がるか、つまり、メールの効果である tau (\\(\\tau\\)) の値を決める。ここでは、0.05ポイント上昇することにしよう。ここで設定する値が本当の因果効果である。 tau &lt;- 0.05 メールの送信が終わった後の購買行動を決める。まず、メール送信後の各人の購買確率を計算する。 Aの購買確率はメールを受け取らなければ pA、受け取れば pA + tau である。同様に、Bの購買確率はメールを受け取らなければ pB、受け取れば pB + tau である。 d1 &lt;- d1 %&gt;% mutate(p_after = ifelse(group == &quot;A&quot;, pA + tau * mail, pB + tau * mail)) 確率によって、商品を買うかどうかをベルヌーイ 試行 (Bernoulli) で決める。つまり、確率 \\(p\\) で表が出るコインを投げて、表が出たら購入し、裏が出たら購入しないと考える。 \\(\\mbox{Bernoulli}(p) = \\mbox{Binomial}(1, p)\\) なので、Rでベルヌーイ試行を実行するには、二項分布 (binomial distribution) から乱数を生成する rbinom()をsize = 1 にして使えば良い。 set.seed(2020) d1 &lt;- d1 %&gt;% mutate(purchase = rbinom(N, size = 1, prob = p_after)) メール受信状況別の購入割合は d1_gr &lt;- d1 %&gt;% mutate(mail = factor(mail, labels = c(&quot;メールなし&quot;, &quot;メールあり&quot;))) %&gt;% group_by(mail) %&gt;% summarize(purchase_rate = mean(purchase)) %&gt;% print() ## # A tibble: 2 x 2 ## mail purchase_rate ## &lt;fct&gt; &lt;dbl&gt; ## 1 メールなし 0.366 ## 2 メールあり 0.574 である。図にすると、 p1 &lt;- ggplot(d1_gr, aes(x = mail, weight = purchase_rate)) + geom_bar(width= 0.5) + labs(x = &quot;&quot;, y = &quot;購買率&quot;) plot(p1) となる。単純に比較すると、 d1_gr %&gt;% pull(purchase_rate) %&gt;% diff() ## [1] 0.208 がメールの効果のように見えてしまう。しかし、実際のメールの効果は、先ほど設定したとおり0.05 である。 ちなみに、この「バイアスを含む効果」は単回帰によっても得られる。 fit &lt;- lm(purchase ~ mail, data = d1) summary(fit) ## ## Call: ## lm(formula = purchase ~ mail, data = d1) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.574 -0.366 -0.366 0.426 0.634 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.36600 0.02185 16.749 &lt; 2e-16 ## mail 0.20800 0.03090 6.731 2.85e-11 ## ## Residual standard error: 0.4886 on 998 degrees of freedom ## Multiple R-squared: 0.04342, Adjusted R-squared: 0.04246 ## F-statistic: 45.3 on 1 and 998 DF, p-value: 2.846e-11 mail の効果の推定値は、0.21 である。また、その \\(p\\)値が\\(2.85 \\times 10^{-11} &lt; 0.001\\) なので、この効果は有意水準0.001（0.1%）で統計的に有意である。単に「統計的に有意かどうか」を調べることには意味がないことがよくわかるだろう。 このように、処置（介入）の値が結果（購入確率）に依存していると、バイアスが生じる。この場合は、効果が過大評価されてしまう。 1回のシミュレーションでは、偶然そうなっただけかもしれないので、これを複数回（できるだけ多く）繰り返そう。 そのために、関数を用意する。返り値（戻り値）は、単純比較から得られる効果の大きさとする。 sim_mail &lt;- function(tau = 0.05, N = 1000, n_mail = N / 2, pA = 0.6, pB = 0.3) { # 引数の条件を設定する：条件を満たさない場合はエラー if (pA &lt;= pB) stop(&quot;pA must be larger than pB.&quot;) if (N &lt; n_mail) stop(&quot;N must be larger than n_mail.&quot;) if (pA &gt; 1 | pB &lt; 0) stop(&quot;pA and pB must be in the range [0, 1].&quot;) if (tau + pA &gt; 1) stop(&quot;beta + pA must be equal to or smaller than 1.&quot;) if (tau + pB &lt; 0) stop(&quot;beta + pB must be equal to or greater than 0.&quot;) group &lt;- rep(c(&quot;A&quot;, &quot;B&quot;), each = N /2) n_receive &lt;- round(n_mail * c(pA, pB) / sum(pA, pB)) mail &lt;- rep(c(1, 0, 1, 0), times = c(n_receive[1], N / 2 - n_receive[1], n_receive[2], N / 2 - n_receive[2])) p_after &lt;- ifelse(group == &quot;A&quot;, pA + tau * mail, pB + tau * mail) purchase &lt;- rbinom(N, size = 1, prob = p_after) fit &lt;- lm(purchase ~ mail) return(coef(fit)[2]) } 試しに、tau = 0.05 で1回シミュレーションしてみる。 sim_mail(tau = 0.05) ## mail ## 0.142 tau、pA、pB の値を変えてみる。 sim_mail(tau = 0.1, pA = 0.8, pB = 0.7) ## mail ## 0.154 最初と同じ条件で、シミュレーションを1000回繰り繰り返してみる。 s1_1000 &lt;- replicate(1000, sim_mail()) この結果を可視化する。本当の因果効果である 0.05 の位置を赤い縦線で示す。 p_s1 &lt;- tibble(tau = s1_1000) %&gt;% ggplot(aes(x = tau, y = after_stat(density))) + geom_histogram(color = &quot;black&quot;, binwidth = 0.02) + geom_vline(xintercept = 0.05, color = &quot;tomato&quot;) + labs(x = &quot;単純比較から得られる「効果」&quot;, y = &quot;確率密度&quot;) plot(p_s1) 本当の効果は0.05なのに、推定された効果の平均値は0.15 、中央値は 0.15 である。 このように、サンプルセレクションのせいでセクションバイアスが生じ、効果が過大推定されることがわかる。 サンプルセレクションの内容によっては、効果が過小評価される場合もある。 2.2.2.1 購買行動のモデリング：発展的内容* この内容はセレクションバイアスとはあまり関係ないので、興味と余力がある人のみ読めば良い。 上の説明では、メールによる販促効果が一定であると考えたが、実際には まったく買う気がない人にはあまり効果がない。 元々買う予定の人にはあまり効果がない。 買うか買わないか迷っている人には効果が大きい。 ということが予想される。そのような効果をモデル化してみよう。 個人 \\(i\\) が商品を買うかどうかを表す変数を \\(Y_i\\) とする。\\(Y_i = 1\\) ならば購入、\\(Y_i = 0\\) ならば非購入とする。\\(Y_i\\) は二値変数なので、個人\\(i\\)が商品を買う確率を \\(\\theta_i\\) として、ベルヌーイ分布で購買モデルを考えることができる。すなわち、 \\[ Y_i \\sim \\mbox{Bernoulli}(\\theta_i) \\] と考える。ここで、購買確率 \\(\\theta_i\\) は、メールがない場合に商品を買おうと思っていた度合い \\(\\alpha\\) と、メールの効果 \\(\\tau\\) によって決まると考える。 \\(\\alpha\\) が0に近ければ買うかどうか迷っている状態、絶対値が大きい負の値ならほとんど買う気がない状態、大きい正の値ならば買うつもりの状態を表す。商品を買いやすい集団Aと買いにくい集団Bがいるとすると、\\(\\alpha\\) も集団ごとに異なると考えられる。そこで、個人 \\(i\\) が属するグループを \\(G_i \\in \\{A, B\\}\\) とすると、この度合いは、\\(\\alpha_{G_i}\\) と表すことができる。 \\(M_i\\) をメールを受け取ったことを表すダミー変数、つまり、メールを受け取れば \\(M_i = 1\\)、受け取らなければ \\(M_i = 0\\) になる変数だとすると、個人 \\(i\\) が商品を買おうと思う「度合い（確率ではない）」は、\\(\\alpha_{G_i} + \\tau M_i\\) と表せる。 この「度合い」は確率ではなく、\\((-\\infty, \\infty)\\) の値をとる。確率は \\([0, 1]\\) でなければいけないので、\\((-\\infty, \\infty)\\) を \\([0, 1]\\) に変換する必要がある。 そのような変換を行うことができる関数の1つが、ロジスティック関数（ロジットの逆関数）である（詳しくは、浅野 ・矢内 (2018) の第15章 を参照されたい）。 この関数を使うと、購買確率は \\[ \\theta_i = \\mathrm{logit}^{-1}(\\alpha_{G_i} + \\tau M_i) \\] となる。ただし、 \\[ \\mathrm{logit}^{-1}(x) = \\frac{\\exp(x)}{1 + \\exp(x)} = \\frac{1}{1 + \\exp(-x)} \\] である。この関数をRで定義しよう。 inv_logit &lt;- function(x) { return(1 / (1 + exp(-x))) } これを使うと、\\(\\tau\\) を1つの値に決めても、それが購買確率 \\(\\theta\\) に与える影響は一定ではなく、\\(\\alpha\\) の大きさに依存して影響の大きさが変化することになる。 グラフにすると、その様子がわかる。 myd &lt;- tibble(x = seq(from = -5, to = 5, length.out = 1000)) %&gt;% mutate(p = inv_logit(x)) p_logistic &lt;- ggplot(myd, aes(x = x, y = p)) + geom_line(color = &quot;royalblue&quot;) + labs(x = expression(alpha[G[i]] + tau * M[i]), y = &quot;購買確率&quot;) plot(p_logistic) グラフが直線ではなく曲線になっており、\\(\\alpha_{G_i} + \\tau M_i\\) の増分が一定でも、横軸上でどこにいるかによって変化の大きさが変わることがわかる。 このような効果を想定してシミュレーションを行うと、結果は変わるだろうか？ 2.2.3 通院と健康状態：セルフセレクション 講義で扱った、病院と健康状態の例 (Angrist and Pischke 2009) を使い、セルフセレクションによるセレクションバイアスをシミュレーションによって確かめてみよう。 まず、全体の人数 \\(N\\) を決める。 N &lt;- 1e4 次に、元々の健康状態をランダムに決める（本当は、ここはランダムでなくても良い）。1が最悪の健康状態、5が最善の状態とする。中程度の健康状態の人のが多いことにする。これは、病院に行く前の「隠れた」健康状態であり、観測されない変数であることに注意しよう。 set.seed(2020-06-09) d2 &lt;- tibble(h_hidden = sample(1:5, size = N, replace = TRUE, prob = c(1, 2, 3, 2, 1))) 隠れた健康状態の分布を確認してみる。 hist_h_hidden &lt;- ggplot(d2, aes(x = h_hidden)) + geom_bar(fill = &quot;tomato&quot;, width = 0.5) + labs(x = &quot;健康状態&quot;, y = &quot;人数&quot;) plot(hist_h_hidden) この隠れた健康状態に基づき、各個人が病院に行くかどうか決められることにしよう。つまり、各個人が処置である「病院に行くこと」を、「隠れた健康状態」という結果に密接に関連する変数に基づいて自己選択する（セルフセレクション）という状況をシミュレートする。 他の条件が等しければ (ceteris paribus)、健康状態が悪いほど病院に行きやすいはずだ。ここではまず、健康状態ごとに病院に行く確率の平均値 \\(\\mu\\) が異なると考えよう。そして、各個人が病院に行く確率は、平均値 \\(\\mu\\) の正規分布からランダムに生成されると考える。話を単純にするため、標準偏差は同じだと仮定する。 （上の「購買行動のモデリング：発展的内容*」の節と同じように、健康状態を説明変数とする線形予測子を、ロジット関数を使って確率に結び付けても良い。） つまり、健康状態が \\(s\\) の人が病院に行く確率 \\(p_s\\) は、\\(p_s \\sim \\mbox{Normal}(\\theta_s, \\sigma)\\) によって決まる。ただし、\\(0 \\leq p_s \\leq 1\\) になるように調整する。例として、健康状態ごとの \\(\\mu_s\\) を \\((\\mu_1, \\mu_2, \\mu_3, \\mu_4, \\mu_5) = (0.75, 0.6, 0.4, 0.3, 0.2)\\) としてみよう。\\(\\sigma\\) は0.1とする。 Rで以下を実行して、各個人の通院確率を決める。 mu &lt;- c(0.75, 0.6, 0.4, 0.3, 0.2) sigma &lt;- 0.1 d2 &lt;- d2 %&gt;% mutate(prob = rnorm(n(), mean = mu[h_hidden], sd = sigma), prob = case_when( prob &gt; 1 ~ 1, prob &lt; 0 ~ 0, TRUE ~ prob )) 健康状態別の通院確率の分布を図示する。 hist_prob &lt;- ggplot(d2, aes(x = prob)) + geom_histogram(binwidth = 0.05, color = &quot;black&quot;) + facet_grid(rows = vars(h_hidden)) + labs(x = &quot;病院に行く確率&quot;, y = &quot;人数&quot;) plot(hist_prob) 健康状態が良い（5の）場合は、ランダムに生成した「確率」が0より小さくなってしまったものを後から0に調整しているので、0の度数が正規分布より大きくなっている。したがって、このモデルは通院を説明するものとしてはあまり望ましくない。しかし、ここでの目的はセルフセレクションによるセレクションバイアスを理解することなので、これで良しとしよう。（気になるなら、もっといいモデルを自分で考えよう！） この確率に基づいて、ベルヌーイ試行で病院に行くかどうかを表す変数 \\(D_i \\in \\{0,1\\}\\) の値を決める。これが観察される処置の値である。 d2 &lt;- d2 %&gt;% mutate(D = rbinom(n(), size = 1, prob = prob)) 病院に行く人の割合は、 mean(d2$D) ## [1] 0.4426 である。（現実よりかなり大きな値になっているが、とりあえずこれで進める。気になるなら、シミュレーションの条件を変えていろいろ試してみよう！） ここで、通院が健康状態に与える平均処置効果 (ATE) beta を設定する。単純化のため、ATE = ITE とする。つまり、処置効果はどの個人にとっても同じだと仮定する。試しに、beta = 0.6 にしてみよう。これは、隠れた健康状態が3の人が病院に行くと健康状態が3.6 になるということである。実際には、健康状態は1から5の整数で観測される。隠れた健康状態が5の人が病院に行っても健康状態は5のままのはずであるが、ここでは5.6になることを許そう。どちらも、シミュレーションを単純化するための妥協である。（調査される整数値の健康状態の背景に連続的な健康状態があり、回答するときに最も近い値を選ぶと考えれば、それほど変な設定ではない。） beta &lt;- 0.6 この効果を、通院した人にのみ与え、健康状態 \\(Y\\) を観測する。 d2 &lt;- d2 %&gt;% mutate(Y = h_hidden + beta * D) これで、データが揃った。シミュレーションでなければ、観測されるのは \\(D\\) と \\(Y\\)のみである。 病院に行った人と行かなかった人の健康状態を単純に比較してみよう。 d2_D &lt;- d2 %&gt;% mutate(D = factor(D, label = c(&quot;病院に行かなかった&quot;, &quot;病院に行った&quot;))) %&gt;% group_by(D) %&gt;% summarize(health = mean(Y)) %&gt;% print() ## # A tibble: 2 x 2 ## D health ## &lt;fct&gt; &lt;dbl&gt; ## 1 病院に行かなかった 3.34 ## 2 病院に行った 3.18 健康状態は、病院に行った人のほうが、病院に行かなかった人よりも悪いことがわかる。 このように、本当の ATE は 0.6 なのに、観察された値を単純比較すると、-0.16 だと誤解してしまう。 これはシミュレーションなので、本来は計算できないはずのセレクションバイアスも計算することができる。 セレクションバイアスは、 \\[ \\mathbb{E}[Y(0) \\mid D = 1 ] - \\mathbb{E}[Y(0) \\mid D = 0] \\] である。これを計算してみよう。 まず、\\(\\mathbb{E}[Y(0) \\mid D = 1]\\)は、 e1 &lt;- d2 %&gt;% filter(D == 1) %&gt;% pull(h_hidden) %&gt;% mean() %&gt;% print() ## [1] 2.580434 である。\\(\\mathbb{E}[Y(0) \\mid D = 0]\\) は、 e0 &lt;- d2 %&gt;% filter(D == 0) %&gt;% pull(h_hidden) %&gt;% mean() %&gt;% print() ## [1] 3.336204 である。よって、この場合のセレクションバイアスは、 (sb &lt;- e1 - e0) ## [1] -0.75577 である。セルフセレクションの影響で、負のセレクションバイアスが生じていることがわかる。ATEとセレクションバイアスを足した値 beta + sb ## [1] -0.15577 は、単純比較による効果の推定値 diff(d2_D$health) ## [1] -0.15577 に一致する。 単純比較による効果の推定を回帰分析で行ってみよう。 fit2 &lt;- lm(Y ~ D, data = d2) summary(fit2) ## ## Call: ## lm(formula = Y ~ D, data = d2) ## ## Residuals: ## Min 1Q Median 3Q Max ## -2.3362 -0.5804 -0.3362 0.6638 2.4196 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.33620 0.01465 227.735 &lt; 2e-16 ## D -0.15577 0.02202 -7.074 1.61e-12 ## ## Residual standard error: 1.094 on 9998 degrees of freedom ## Multiple R-squared: 0.00498, Adjusted R-squared: 0.004881 ## F-statistic: 50.04 on 1 and 9998 DF, p-value: 1.606e-12 （当たり前だが）上と同じ推定値が得られた。また、その効果は有意水準0.001 で統計的に有意である。繰り返すが、「統計的に有意」な結果を見つけても、それ自体は因果推論の役に立たないことが、ここからわかるだろう。 以上のシミュレーションを、繰り返し実行できるように関数にまとめよう。返り値は、単純比較によって得られる「バイ アスを含んだ因果効果」とする。 sim_hospital &lt;- function(beta = 0.6, N = 1e4, mu = c(0.75, 0.6, 0.4, 0.3, 0.2), sigma = rep(0.1, 5)) { # sigma は、健康状態ごとに変えても良いことにする if (length(sigma == 1)) sigma &lt;- rep(sigma, 5) h_hidden &lt;- sample(1:5, size = N, replace = TRUE, prob = c(1, 2, 3, 2, 1)) prob &lt;- rnorm(N, mean = mu[h_hidden], sd = sigma[h_hidden]) prob &lt;- case_when( prob &gt; 1 ~ 1, prob &lt; 0 ~ 0, TRUE ~ prob ) D &lt;- rbinom(N, size = 1, prob = prob) Y &lt;- h_hidden + beta * D fit &lt;- lm(Y ~ D) return(coef(fit)[2]) } beta = 0.6 でこの関数を1度だけ実行してみる。 sim_hospital(beta = 0.6) ## D ## -0.1743207 シミュレーションを1000回繰り返してみよう。 s2_1000 &lt;- replicate(1000, sim_hospital()) この結果を図示する。 p_s2 &lt;- tibble(beta = s2_1000) %&gt;% ggplot(aes(x = beta, y = after_stat(density))) + geom_histogram(color = &quot;black&quot;, binwidth = 0.01) + #geom_vline(xintercept = 0.6, color = &quot;tomato&quot;) + labs(x= &quot;単純比較から得られる「効果」&quot;, y = &quot;確率密度&quot;) plot(p_s2) 本当の因果効果は0.6である。しかし、1,000回のシミュレーションで推定された因果効果の平均値は-0.17、中央値は-0.17であり、効果を大幅に過小推定している。 セルフセレクションによって、セレクションバイアスが生じているためである。 このように、セレクションバイアスは因果推論の敵である。今回の例では負のバイアスが生じ、本来は正であるはずの効果を負だと誤解する危険があることがわかった。しかし、セレクションの内容によっては、負の効果を正と誤解したり、弱い正の効果を強い正の効果だと誤解したりするようなことも考えられる。 セレクションバイアスが生じるような状況では、単純比較（単回帰）によって因果効果を推定することはできない。 2.3 トピック2の課題 上で行ったシミュレーションを、条件を変えて色々試しなさい。また、面白い結果や納得できない結果が出たら、Slack でシェアし、受講生同士で議論しなさい。 今回の課題は提出不要だが、必ず自分で実行すること。 参考文献 "],
["RCT.html", "Topic 3 RCT（ランダム化比較試験） 3.1 予習、講義動画、実習課題 3.2 ランダム化のシミュレーション 3.3 トピック3の課題", " Topic 3 RCT（ランダム化比較試験） トピック3の講義スライド (PDF, 1.4MB) 3.1 予習、講義動画、実習課題 このトピックでやるべきことは、以下のとおりである。 シラバス(PDFファイル) に記載されているトピック3の予習課題を読む。 KUTLMS (Moodle) にあるトピック3の講義動画を視聴する。 この資料の続きを読み、Rを使った実習を行うことでRCTの理解を深める。 まず、書いてあるコードをそのまま実行する。 自分で数字（シミュレーションの条件）を変えて、結果がどう変わるか研究する（課題）。 （おまけ：希望者のみ）Josh Angrist による以下の解説動画（英語）を視聴する。 Randomized Trials: The Ideal Weapon 教科書 (安井 2020) 第1章のRを使った分析を自分でやってみる（課題）。 3.2 ランダム化のシミュレーション 3.2.1 準備 必要なパッケージを読み込み、作図用の日本語フォントを設定する。 pacman::p_load(tidyverse, patchwork) theme_set(theme_gray(base_size = 10, base_family = &quot;HiraginoSans-W3&quot;)) # macOS用 #theme_set(theme_gray(base_size = 10, base_family = &quot;Meiryo&quot;)) # Windows用 #theme_set(theme_gray(base_size = 10, base_family = &quot;ipaex&quot;)) # Ubuntu用 #showtext::showtext_auto() # Cloud用 #theme_set(theme_gray(base_size = 10, base_family = &quot;noto&quot;)) # Cloud用 3.2.2 母集団の設定 ある処置 \\(D\\) の平均処置効果が正であると仮定して、母集団のデータを作る。 共変量として二値の性別と、年齢（20歳から65歳）を考える。 set.seed(2020-06-09) N &lt;- 1e6 y_1_m &lt;- rnorm(N, mean = 10, sd = 4) y_1_f &lt;- rnorm(N, mean = 12, sd = 4) y_0_m &lt;- rnorm(N, mean = 0, sd = 2) y_0_f &lt;- rnorm(N, mean = 4, sd = 2) age &lt;- sample(20:65, size = N, replace = TRUE) df_pop &lt;- tibble(id = 1:N, age = age) %&gt;% mutate(male = rbinom(n(), size = 1, prob = 0.5), y_1 = ifelse(male, y_1_m, y_1_f) + 0.05 *(age - mean(age)), y_0 = ifelse(male, y_0_m, y_0_f) + 0.05 *(age - mean(age)), ITE = y_1 - y_0) 作成した母集団の特徴を確認する。 summary(df_pop) ## id age male y_1 ## Min. : 1 Min. :20.00 Min. :0.0000 Min. :-9.407 ## 1st Qu.: 250001 1st Qu.:31.00 1st Qu.:0.0000 1st Qu.: 8.176 ## Median : 500000 Median :42.00 Median :1.0000 Median :10.999 ## Mean : 500000 Mean :42.48 Mean :0.5003 Mean :10.999 ## 3rd Qu.: 750000 3rd Qu.:54.00 3rd Qu.:1.0000 3rd Qu.:13.823 ## Max. :1000000 Max. :65.00 Max. :1.0000 Max. :31.507 ## y_0 ITE ## Min. :-10.5585 Min. :-12.437 ## 1st Qu.: -0.1295 1st Qu.: 5.901 ## Median : 1.9970 Median : 9.008 ## Mean : 1.9990 Mean : 9.000 ## 3rd Qu.: 4.1286 3rd Qu.: 12.092 ## Max. : 13.3120 Max. : 31.514 ITE（個体の処置効果）の分布を確認しておこう。 pop_ite &lt;- ggplot(df_pop, aes(x = ITE), after_stat(density)) + geom_histogram(color = &quot;black&quot;) + labs(y = &quot;確率密度&quot;, title = &quot;母集団における処置効果&quot;) plot(pop_ite) 平均処置効果を計算しておこう。 ## 平均処置効果 pop_ATE &lt;- mean(df_pop$ITE) %&gt;% print() ## [1] 8.999995 ## 男性における平均処置効果 pop_ATE_m &lt;- df_pop %&gt;% filter(male == 1) %&gt;% with(mean(ITE)) %&gt;% print() ## [1] 9.993789 ## 女性における平均処置効果 pop_ATE_f &lt;- df_pop %&gt;% filter(male == 0) %&gt;% with(mean(ITE)) %&gt;% print() ## [1] 8.005113 以下では、この母集団に対して異なる方法でRCTを実施した場合にどのような結果が得られるか、シミュレーションで確かめよう。 3.2.3 ベルヌーイ実験 ベルヌーイ実験 (Bernoulli experiments) をRで実行しよう。まず、シミュレーションを繰り返し行うために、実験を実行する関数を作る。標本サイズ（1回の実験における被験者数） を sample_size で、各ベルヌーイ試行で処置に割付ける確率を prob で指定できるようにする。 bern_experiment &lt;- function(population, sample_size = 100, prob = 0.5, info = FALSE) { df &lt;- slice_sample(.data = population, n = sample_size) df &lt;- df %&gt;% mutate(D = rbinom(n(), size = 1, prob = prob)) ATE &lt;- with(df, mean(y_1[D == 1]) - mean(y_0[D == 0])) if (info) cat(&#39;処置群の個体数:&#39;, sum(df$D), &#39;; 統制群の個体数:&#39;, sample_size - sum(df$D), &#39;\\n&#39;) return(ATE) } この関数を使ってベルヌーイ実験を1度実行してみる。sample_size = 100、prob = 0.5 とする（既定値なので指定しなくて良い）。 bern_experiment(population = df_pop, info = TRUE) ## 処置群の個体数: 57 ; 統制群の個体数: 43 ## [1] 8.538327 もう1回やってみる。 bern_experiment(population = df_pop, info = TRUE) ## 処置群の個体数: 48 ; 統制群の個体数: 52 ## [1] 9.082204 もう1回やってみる。 bern_experiment(population = df_pop, info = TRUE) ## 処置群の個体数: 47 ; 統制群の個体数: 53 ## [1] 8.429646 当然ながら、実験結果は毎回変わる。 実験を1000回繰り返し、結果を図示してみよう。母集団における本当の平均因果効果を赤い縦線で示す。 標本サイズは100である。 bern_100 &lt;- replicate(1000, bern_experiment(df_pop)) hist_bern_100 &lt;- tibble(ATE = bern_100) %&gt;% ggplot(aes(x = ATE)) + geom_histogram(binwidth = 0.2, color = &quot;black&quot;) + geom_vline(xintercept = pop_ATE, color = &quot;tomato&quot;) + labs(y = &quot;度数&quot;, title = &quot;ベルヌーイ実験&quot;) plot(hist_bern_100) 1つひとつの実験は必ずしも ATE を正確に推定しているわけではないが、平均すれば正しい効果を推定できていることがわかる。「正しい」ATEが9 であるのに対し、RCT による推定の平均値は 9 である。 処置に割付ける確率は、0.5 でなくても良い。 bern_experiment(population = df_pop, prob = 0.8, info = TRUE) ## 処置群の個体数: 78 ; 統制群の個体数: 22 ## [1] 9.000707 bern_experiment(population = df_pop, prob = 0.2, info = TRUE) ## 処置群の個体数: 18 ; 統制群の個体数: 82 ## [1] 7.948835 bern_experiment(population = df_pop, prob = 0.1, info = TRUE) ## 処置群の個体数: 10 ; 統制群の個体数: 90 ## [1] 7.335998 bern_p80 &lt;- replicate(1000, bern_experiment(df_pop, prob = 0.8)) hist_bern_p80 &lt;- tibble(ATE = bern_p80) %&gt;% ggplot(aes(x = ATE)) + geom_histogram(binwidth = 0.2, color = &quot;black&quot;) + geom_vline(xintercept = pop_ATE, color = &quot;tomato&quot;) + labs(y = &quot;度数&quot;) plot(hist_bern_p80) 標本サイズ（被験者の数）を変えるとどうなるだろうか。 標本サイズが30の場合： bern_30 &lt;- replicate(1000, bern_experiment(df_pop, sample_size = 30)) hist_bern_30 &lt;- tibble(ATE = bern_30) %&gt;% ggplot(aes(x = ATE)) + geom_histogram(binwidth = 0.2, color = &quot;black&quot;) + geom_vline(xintercept = pop_ATE, color = &quot;tomato&quot;) + labs(y = &quot;度数&quot;) plot(hist_bern_30) 標本サイズが50の場合： bern_50 &lt;- replicate(1000, bern_experiment(df_pop, sample_size = 50)) hist_bern_50 &lt;- tibble(ATE = bern_50) %&gt;% ggplot(aes(x = ATE)) + geom_histogram(binwidth = 0.2, color = &quot;black&quot;) + geom_vline(xintercept = pop_ATE, color = &quot;tomato&quot;) + labs(y = &quot;度数&quot;) plot(hist_bern_50) 標本サイズが500の場合： bern_500 &lt;- replicate(1000, bern_experiment(df_pop, sample_size = 500)) hist_bern_500 &lt;- tibble(ATE = bern_500) %&gt;% ggplot(aes(x = ATE)) + geom_histogram(binwidth = 0.2, color = &quot;black&quot;) + geom_vline(xintercept = pop_ATE, color = &quot;tomato&quot;) + labs(y = &quot;度数&quot;) plot(hist_bern_500) 標本サイズが小さくても、平均的には正しい因果効果を推定できている。 しかし、標本サイズが小さいと、推定のばらつき（標準誤差）が大きくなる。 sd(bern_30) ## [1] 1.303407 sd(bern_50) ## [1] 1.004959 sd(bern_100) ## [1] 0.7140102 sd(bern_500) ## [1] 0.330548 標準誤差が大きいと、過小推定や過大推定が多くなることがわかる。実験を1回（2回、3回）しか行わないなら、標本サイズを十分な大きさにしないと、過小推定や過大推定をしてしまうかもしれない。 3.2.4 完全ランダム化実験 次に、完全ランダム化実験 (completely random experiments) を行う。 sample_size と、処置に割付ける個体の数 n_treated を選べるようにする。ただし、sample_size &gt; n_treated である。 cr_experiment &lt;- function(population, sample_size = 100, n_treated = ceiling(sample_size / 2), info = FALSE) { if (sample_size &lt;= n_treated | n_treated &lt;= 0) stop(&#39;n_treated must be a positive integer smaller than sample_size.&#39;) df &lt;- slice_sample(.data = population, n = sample_size) %&gt;% mutate(D = sample(rep(c(1, 0), c(n_treated, sample_size - n_treated)), size = sample_size, replace = FALSE)) ATE &lt;- with(df, mean(y_1[D == 1]) - mean(y_0[D == 0])) if (info) cat(&#39;処置群の個体数:&#39;, n_treated, &#39;; 統制群の個体数:&#39;, sample_size - n_treated, &#39;\\n&#39;) return(ATE) } sample_size = 100、n_treatd = 50 （どちらも既定値）にして、1回実験を行ってみよう。 cr_experiment(df_pop, info = TRUE) ## 処置群の個体数: 50 ; 統制群の個体数: 50 ## [1] 8.584128 もう1度やってみる。 cr_experiment(df_pop, info = TRUE) ## 処置群の個体数: 50 ; 統制群の個体数: 50 ## [1] 9.89403 この実験を1000回繰り返し、結果を可視化しよう。 cr_100 &lt;- replicate(1000, cr_experiment(df_pop)) hist_cr_100 &lt;- tibble(ATE = cr_100) %&gt;% ggplot(aes(x = ATE)) + geom_histogram(binwidth = 0.2, color = &quot;black&quot;) + geom_vline(xintercept = pop_ATE, color = &quot;tomato&quot;) + labs(y = &quot;度数&quot;, title = &quot;完全ランダム化実験&quot;) plot(hist_cr_100) やはり、平均的にはうまく推定できているようだ。ATEの推定値の平均値は、9 である。 完全ランダム化実験で処置に割付ける数は、標本サイズの半分でなくても良い。 cr_experiment(df_pop, sample_size = 100, n_treated = 70, info = TRUE) ## 処置群の個体数: 70 ; 統制群の個体数: 30 ## [1] 7.992297 cr_experiment(df_pop, sample_size = 100, n_treated = 25, info = TRUE) ## 処置群の個体数: 25 ; 統制群の個体数: 75 ## [1] 9.782785 この実験を1000回繰り返し、結果を可視化しよう。 cr_prop20 &lt;- replicate(1000, cr_experiment(df_pop, sample_size = 100, n_treated = 20)) hist_cr_prop20 &lt;- tibble(ATE = cr_prop20) %&gt;% ggplot(aes(x = ATE)) + geom_histogram(binwidth = 0.2, color = &quot;black&quot;) + geom_vline(xintercept = pop_ATE, color = &quot;tomato&quot;) + labs(y = &quot;度数&quot;) plot(hist_cr_prop20) 標本サイズ（被験者数）の20％のみを処置に割付けても、平均的には正しいATEを推定できる。 3.2.5 ブロック別ランダム化実験 続いて、ブロック別ランダム化実験 (stratified randomized experiments) を実施してみよう。 ここでは、性別（男性ダミー変数）によってブロックを作る。 処置に割付ける数は、各群における処置の割合で指定できるようにする。 例えば、男性ブロックでは7割を処置、女性ブロックでは4割を処置するなら、prop = c(0.7, 0.4) と指定できるようにする。 strat_experiment &lt;- function(population, sample_size = 100, prop = c(0.5, 0.5), info = FALSE) { if (min(prop) &lt;= 0 | max(prop) &gt;= 1) stop(&quot;prop must be in (0, 1).&quot;) df &lt;- slice_sample(.data = population, n = sample_size) Male &lt;- df %&gt;% filter(male == 1) Female &lt;- df %&gt;% filter(male == 0) n_treated &lt;- ceiling(c(nrow(Male), nrow(Female)) * prop) ATE_male &lt;- cr_experiment(Male, sample_size = nrow(Male), n_treated = n_treated[1]) ATE_female &lt;- cr_experiment(Female, sample_size = nrow(Female), n_treated = n_treated[2]) male_prop &lt;- mean(df$male) ATE &lt;- male_prop * ATE_male + (1 - male_prop) * ATE_female if (info) { cat(&#39;男性ブロック 処置群の個体数&#39;, n_treated[1], &#39;; 統制群の個体数:&#39;, nrow(Male) - n_treated[1], &#39;\\n&#39;) cat(&#39;女性ブロック 処置群の個体数&#39;, n_treated[2], &#39;; 統制群の個体数:&#39;, nrow(Female) - n_treated[2], &#39;\\n&#39;) } return(ATE) } sample_size = 100、prop = c(0.5, 0.5) （どちらも既定値）として、1回実験してみる。 strat_experiment(df_pop, info = TRUE) ## 男性ブロック 処置群の個体数 28 ; 統制群の個体数: 27 ## 女性ブロック 処置群の個体数 23 ; 統制群の個体数: 22 ## [1] 8.558515 もう1度やってみる strat_experiment(df_pop, info = TRUE) ## 男性ブロック 処置群の個体数 26 ; 統制群の個体数: 26 ## 女性ブロック 処置群の個体数 24 ; 統制群の個体数: 24 ## [1] 8.715336 この実験を1000回繰り返し、結果を可視化しよう。 strat_100 &lt;- replicate(1000, strat_experiment(df_pop)) hist_strat_100 &lt;- tibble(ATE = strat_100) %&gt;% ggplot(aes(x = ATE)) + geom_histogram(binwidth = 0.2, color = &quot;black&quot;) + geom_vline(xintercept = pop_ATE, color = &quot;tomato&quot;) + labs(y = &quot;度数&quot;, &quot;ブロック別ランダム化実験&quot;) plot(hist_strat_100) やはり、平均的にはうまく推定できているようだ。ATEの推定値の平均値は、9.01 である。 処置する個体の数（割合）は、ブロックごとに変えても良い。 strat_experiment(df_pop, prop = c(0.3, 0.15), info = TRUE) ## 男性ブロック 処置群の個体数 17 ; 統制群の個体数: 38 ## 女性ブロック 処置群の個体数 7 ; 統制群の個体数: 38 ## [1] 9.260837 strat_experiment(df_pop, prop = c(0.8, 0.1), info = TRUE) ## 男性ブロック 処置群の個体数 42 ; 統制群の個体数: 10 ## 女性ブロック 処置群の個体数 5 ; 統制群の個体数: 43 ## [1] 9.769045 1000回繰り返してみよう。 strat_b &lt;- replicate(1000, strat_experiment(df_pop, prop = c(0.8, 0.2))) hist_strat_b &lt;- tibble(ATE = strat_b) %&gt;% ggplot(aes(x = ATE)) + geom_histogram(binwidth = 0.2, color = &quot;black&quot;) + geom_vline(xintercept = pop_ATE, color = &quot;tomato&quot;) + labs(y = &quot;度数&quot;) plot(hist_strat_b) ブロックごとに処置に割り付ける割合が違っても、平均的には正しい推定ができる。 3.2.6 ペア毎のランダム化実験 4番目の方法として、ペア毎のランダム化試験 (paired randomized experiments) を実施しよう。 サンプルの中で、性別が同じで、年齢が近い者同士をペアにして、ペア毎に一方を処置に、他方を統制に割付ける。 ペアを組む都合上、標本サイズは偶数に制限し、サンプル内の男女の数がそれぞれ偶数になるように調整する。 paired_experiment &lt;- function(population, sample_size = 100) { ## sample_size が奇数の場合はエラー if (sample_size %% 2 != 0) stop(&quot;sample_size must be an even number.&quot;) n_male &lt;- sample_size / 2 if (n_male %% 2 != 0) n_male &lt;- n_male + sample(c(-1, 1), size = 1) n_female &lt;- sample_size - n_male Male &lt;- population %&gt;% filter(male == 1) %&gt;% slice_sample(n = n_male) %&gt;% arrange(age) %&gt;% mutate(D = as.vector(replicate(n() / 2, sample(0:1, size = 2)))) Female &lt;- population %&gt;% filter(male == 0) %&gt;% slice_sample(n = n_female) %&gt;% arrange(age) %&gt;% mutate(D = as.vector(replicate(n() / 2, sample(0:1, size = 2)))) df &lt;- bind_rows(Male, Female) ATE &lt;- with(df, mean(y_1[D == 1]) - mean(y_0[D == 0])) return(ATE) } 標本サイズ sample_size = 100 （既定値）で1回実験してみる。 paired_experiment(df_pop) ## [1] 8.230426 もう1回やってみよう。 paired_experiment(df_pop) ## [1] 8.688203 この実験を1000回繰り返し、結果を可視化しよう（そこそこ時間がかかるので注意）。 pair_100 &lt;- replicate(1000, paired_experiment(df_pop)) hist_pair_100 &lt;- tibble(ATE = pair_100) %&gt;% ggplot(aes(x = ATE)) + geom_histogram(binwidth = 0.2, color = &quot;black&quot;) + geom_vline(xintercept = pop_ATE, color = &quot;tomato&quot;) + labs(y = &quot;度数&quot;, title = &quot;ペア毎のランダム化実験&quot;) plot(hist_pair_100) やはり、平均的にはうまく推定できているようだ。ATEの推定値の平均値は、9.02 である。 各ペアで処置に割り付ける確率は、0.5 でなくても良い。自分で確かめてみよう。 3.2.7 4つのRCT を比較する 最後に、それぞれのRCTの推定精度を比較しよう。どれも標本サイズは100で、処置の確率・割合・数が全体の半分（程度）になるようにしたものを比べる。 1000回の実験をシミュレートしたヒストグラムを再掲する。 MIN &lt;- min(c(bern_100, cr_100, strat_100, pair_100)) - 0.2 MAX &lt;- max(c(bern_100, cr_100, strat_100, pair_100)) + 0.2 ((hist_bern_100 + xlim(MIN, MAX) + ylim(0, 150)) + (hist_cr_100 + xlim(MIN, MAX) + ylim(0, 150))) / ((hist_strat_100 + xlim(MIN, MAX) + ylim(0, 150)) + (hist_pair_100 + xlim(MIN, MAX) + ylim(0, 150))) 標準誤差を比較する。 sd(bern_100) ## [1] 0.7140102 sd(cr_100) ## [1] 0.6964512 sd(strat_100) ## [1] 0.6364027 sd(pair_100) ## [1] 0.6304716 このように、処置のパタンの数が最も少ない（かつブロック[ペア]がより同質的な）ペア毎のランダム化実験の標準誤差が最も小さく、推定精度が高いことがわかる。 経済実験におけるランダム化について、さらに詳細な説明は List, Sadoff, and Wagner (2011) を参照。また、RCT全般については、実験経済学（岡野先生）と実験デザイン（小谷先生）の授業で詳しく扱うはずなので、それらの授業まだ受講していない人はぜひ受講してほしい。 3.3 トピック3の課題 上で行ったシミュレーションを、条件を変えて試し、どのような場合に実験がうまくいき、どのような条件だと失敗しやすいか研究しなさい。また、面白い結果や納得できない結果が出たら、Slack でシェアし、受講生同士で議論しなさい。 教科書 (安井 2020) 第1章の1.4節 (pp.24-33) の分析を自分で実行しなさい。 今回の課題はいずれも提出不要だが、必ず自分で実行すること。 参考文献 "],
["regression.html", "Topic 4 回帰分析", " Topic 4 回帰分析 準備中 "],
["propensity-score.html", "Topic 5 傾向スコア", " Topic 5 傾向スコア 準備中 "],
["panel-data.html", "Topic 6 パネルデータ分析", " Topic 6 パネルデータ分析 準備中 "],
["midterm-presentation.html", "Topic 7 分析計画のプレゼンテーション 7.1 このトピックでやるべきこと 7.2 分析計画のプレゼンテーション 7.3 他の受講生へのコメントについて", " Topic 7 分析計画のプレゼンテーション 7.1 このトピックでやるべきこと 自分の分析計画のプレゼンテーションを行う！ 他の受講生のプレゼンテーションを視聴する。 他の受講生の分析計画にコメントする。 各自、自分以外の2人のプレゼンテーションにコメントする。 誰がどのプレゼンテーションにコメントするかは、担当教員が決める。 割り当てられていない相手のプレゼンテーションにコメントすることは自由。 以下の説明をよく読んでプレゼンテーションを用意すること。 この課題には事前の準備が必要なので、早めに取り組むこと。特に、自分の研究に使えそうなデータを探す必要があることに注意。 7.2 分析計画のプレゼンテーション 7.2.1 プレゼンテーションの内容 以下の内容をすべて含むプレゼンテーションを行いなさい。 因果効果（処置効果）に関するリサーチクエスチョン 特定したい因果効果を明確にすること 例：「大学への進学は、生涯賃金を増やすか？」 例：「猫を飼うと、大学の成績は良くなるか？」 研究の対象となる母集団 因果効果の推定に用いる方法 因果効果の推定に用いるデータ 自分が選んだデータと推定方法で、自分のリサーチクエスチョンに答えらえると考える理由 プレゼンテーション時間は5分以上10分以内を目安とする（多少の時間超過は見逃すので、動画編集に余計な時間を費やす必要はない）。 スライドを作る際は、伝わるデザイン を参考に。 7.2.2 プレゼンテーションの方法 プレゼンテーションの条件：スライドを用いた音声つきの動画でプレゼンテーションを行うこと。 動画ファイルは、できれば MP4 形式 (.mp4) または M4V 形式 (.m4v) が望ましい。MP4またはM4V にできないときは相談してほしい。 その他の内容・動画の作り方は自由。自分の姿を写すかどうかも自由。動画は Slack で共有するので、私だけでなく、他の受講生も全員視聴することに注意。 自宅で声が出せない事情がある場合は、6月中に連絡してほしい。 7.2.3 プレゼンテーション動画の作成法 動画の作成法は自由である。例として、簡単な動画の作り方をいくつか提案し、それぞれの方法についての説明が記載されているウェブサイトを紹介する。他に良い方法があれば、Slack で共有してほしい。 7.2.3.1 Zoom ミーティングを録画する Zoom のミーティングを1人で行い、スライド画面を共有して録画すれば動画 (MP4 ファイル）ができる。おそらく、これが1番簡単である。 参考1 参考2 参考3 注意：無料版の Zoom ではクラウドレコーディングが使えないので、ローカルレコーディングを使う。 7.2.3.2 Keynote プレゼンテーションに音声を付ける MacのKeynote でスライドを作った場合は、この方法が使える。 参考4 参考5 参考6 7.2.3.3 PowerPoint に音声を付ける Microsoft Office PowerPoint でスライドを作った場合は、この方法が使える。 参考7 参考8 参考9 注意：ファイルを保存する際は、MP4を選択する。 7.2.4 提出方法と提出期限 提出方法：Slack の # プレゼン1_分析計画 チャンネルに投稿する。 提出するファイル（2つ提出） プレゼンテーションの動画 MP4 または M4V のファイル ファイル名：metrics_mid_LastFirst.mp4 （または metrics_mid_LastFirst.m4v） プレゼンテーションに使用したスライド 必ず PDF ファイル に変換すること ファイル名：metrics_mid_LastFirst.pdf 提出期限：7月17日（金）正午（日本時間） 7.3 他の受講生へのコメントについて このコメントも成績評価の対象になる。提出までの期間が短いので注意。 コメントの内容 分析計画の良いところをできるだけたくさん見つける。 計画の良くないところを批判する（その研究を改善することが目的であることを忘れずに） 良くないと思う理由をできるだけわかりやすく説明する。 どうすればもっと良くなるか、代替案を提示する。 提出するファイル コメントをまとめた PDF ファイル 2人に対するコメントを1つのファイルにまとめる。 誰に対するコメントかわかるようにすること。 ファイル名：metrics_comment_LastFirst.pdf 分量は自由（目安：1つの報告に対し1ページ） 提出方法：Slack の # プレゼン1_分析計画 チャンネルに投稿する。 7月17日（金）の正午以降に投稿すること。 提出期限：7月21日（火曜）正午（日本時間） 自分がコメントを担当する相手のプレゼンテーションが締切までに提出されなかったときは、遅れた分だけこの締め切りも延ばす（Slack上の投稿日時を基準にする）。 "],
["regression-discontinuity.html", "Topic 8 回帰不連続デザイン", " Topic 8 回帰不連続デザイン 準備中 "],
["instrumental-variable.html", "Topic 9 操作変数法", " Topic 9 操作変数法 準備中 "],
["final-presentation.html", "Topic 10 分析結果のプレゼンテーション 10.1 このトピックでやるべきこと 10.2 分析結果のレポート（期末レポート） 10.3 分析結果のプレゼンテーション", " Topic 10 分析結果のプレゼンテーション 10.1 このトピックでやるべきこと 分析結果をレポートにまとめて提出する。 分析結果の概要を発表する。 他の受講生のプレゼンテーションを視聴する。 以下の説明をよく読み、レポートとプレゼンテーションを用意すること。 10.2 分析結果のレポート（期末レポート） 10.2.1 レポートの内容 以下の内容を含むレポートを提出しなさい。 リサーチクエスチョン 分析計画のプレゼンテーションで発表した計画からの変更点 変更点がない場合は不要 計画全体を大幅に変更した（たとえば、リサーチクエスチョンを変えた）場合は、研究計画のプレゼンテーションで要求された内容も含めること 推定に用いた方法と統計モデル（推定に利用する式） 分析に用いたデータの説明 分析結果を示す図（図がないものは減点する） 分析結果の解釈 「統計的に有意」だけでは不十分：統計的に有意だからどうした？ リサーチクエスチョンに対する回答 どういうデータ（今回の分析では手に入らなかったが、自分が理想とするデータ）があれば、因果効果の推定がもっとうまくいくと考えられるか？ 注意：「うまくいく」は、統計的に有意な結果を出すことではない。 10.2.2 レポートの形式と提出方法 形式 レポートはR Markdown で書く R Markdown を knit してPDF ファイルを作る 提出するファイル R Markdown ファイル ファイル名：metrics_final_LastFirst.Rmd PDF ファイル ファイル名：metrics_final_LastFirst.pdf レポートに必要ないと思われるモノ（例：Rのwarnigs）は、見えないようにすることが望ましい 分析に使ったデータセット 私と共有できない事情がある場合は提出しなくてもよいが、提出期限より前に（できれば分析計画のプレゼンの際に）申し出ること 共有できない例：他の教員と共同で実施した実験データで、そのデータを使ってこれから論文を書く予定 共有できない例：データの利用申請を提出して手に入れたデータ Rで読み込みめれば形式は自由（例：.csv, .tsv, Rds） ファイル名は自由（よく考えてファイル名を付けるように） データセットは複数のファイルに分かれていても良い データを提出できない場合は、データに関する詳しい説明をレポートに含めること 提出方法 Slack のダイレクトメッセージで提出 提出期限：8月5日（水）正午（日本時間） 10.3 分析結果のプレゼンテーション 10.3.1 プレゼンテーションの内容 分析結果の概要を発表してもらう。時間に限りがあるので、分析結果のうち自分が注目すべきだと思う点に焦点を絞って発表すること。 プレゼンテーション時間は5分以上10分以内を目安とする（多少の時間超過は見逃すので、動画編集に余計な時間を費やす必要はない）。 プレゼンテーション動画の作り方について、Topic 7 を参照。 10.3.2 提出方法と提出期限 提出方法：Slack の # プレゼン2_分析結果 チャンネルに投稿する。 提出するファイル（2つ提出） プレゼンテーションの動画 MP4 または M4V のファイル ファイル名：metrics_result_LastFirst.mp4 （または metrics_result_LastFirst.m4v） プレゼンテーションに使用したスライド 必ず PDF ファイル に変換すること ファイル名：metrics_result_LastFirst.pdf 提出期限：8月5日（水）正午（日本時間） "],
["references.html", "参考文献", " 参考文献 Angrist, Joshua D., and Jörn-Steffen Pischke. 2009. Mostly Harmless Econometrics: An Empiricist’s Companion. Princeton: Princeton University Press. List, John A., Sally Sadoff, and Mathis Wagner. 2011. “So You Want to Run an Experiment, Now What? Some Simple Rules of Thumb for Optimal Experimental Design.” Experimental Economics 14: 439. https://doi.org/10.1007/s10683-011-9275-7. 安井翔太. 2020. 効果検証入門：正しい比較のための因果推論/計量経済学の基礎. 技術評論社. "]
]
